"""""" General options

colorscheme jellybeans+

set softtabstop=4
set tabstop=4
set shiftwidth=4
set noexpandtab

" Put in a highlight after column 100
set colorcolumn=101
"set tw=100

" Highlight the line the cursor is on
set cursorline

" New splits open to the right, or bottom
set splitright
set splitbelow

" Show (partial) command in last line of screen. No idea what it does.
set showcmd

" Don't put "--INSERT--" in command bar when going into insert mode
set noshowmode

" Don't ignore *.out files (as is the Janus default)
set wildignore-=*.out
" Do ignore *.tmp files
set wildignore+=*.tmp


"""""" Startup commands

" If more than one file is passed to Vim on startup, open each in its own tab
function! Open_all_files_in_tabs()
		if len(argv()) > 1
				" Save the current tab
				let l:currentTab = tabpagenr()
				" `tab`: run the following command and create tabs when it
				" creates windows
				" `sball`: create a window for each buffer
				execute "tab sball"
				" Restore the original tab we opened
				execute 'tabnext' l:currentTab
		endif
endfunction


augroup VimrcStartup
		" 'nested' allows autocmds that run on opening a buffer (such as
		" detecting " filetype) run. Otherwise, all further autocmds prevented
		" from running.
		autocmd VimEnter * nested call Open_all_files_in_tabs()
augroup end


"""""" New commands & shortcuts

" `:VimRC[!]` : Opens all vimrc in separate tabs. If ! is present, will open
" the tabs in the current Vim instance. Otherwise, runs a new MacVim instance
" with the tabs open on startup.
command -bang VimRC call VimEditRC("<bang>")
" <leader>db : Delete buffers not currently loaded in a window
nmap <leader>db :call BufDeleteInvisible()<CR>
" <leader>ml : Append modeline after last line in buffe
nnoremap <silent> <Leader>ml :call AppendModeline()<CR>


"" Functions supporting the above commands

function VimEditRC(bBang)
	" If the command is not proceeded by a '!', open a new MacVim instance
	" and execute commands to load the vimrc files into tabs on startup.
	if a:bBang != "!"
		exec "silent !mvim -c 'edit ~/.vimrc.before' -c 'tabedit ~/.vimrc.after' -c 'tabedit ~/.gvimrc.before' -c 'tabedit ~/.gvimrc.after' -c 'tabnext 2'"
	else
		" If the command is proceeded by a '!', create new tabs directly in
		" this instance of Vim with the vimrc files.
		
		" If the current buffer is empty (only has one buffer, that buffer has
		" a blank filename, is one line long, and that line has no content),
		" load the first file into the current tab.
		if len(tabpagebuflist()) == 1 && bufname("%") == "" && line('$') == 1 && getline(1) == ''
			exec "e ~/.vimrc.before"
		else
			exec "tabedit ~/.vimrc.before"
		endif
		exec "tabedit ~/.vimrc.after"
		let l:vimrcafter = tabpagenr()
		exec "tabedit ~/.gvimrc.before"
		exec "tabedit ~/.gvimrc.after"
		exec "tabnext " . l:vimrcafter
	endif
endfunction

function! BufDeleteInvisible()
	" For each tab page, finds the visible buffers and sets the appropriate
	" key
	" in the dictionary.
	let l:visiblebufs = {}
	for i in range(1, tabpagenr('$'))
		for b in tabpagebuflist(i)
			let l:visiblebufs[b] = 1
		endfor
	endfor

	" Keeps tracks of the buffers we delete so we can show the user a message
	" about what we did when we're done.
	let l:closed = []
	" Iterates through each possible buffer number. If that buffer is in the
	" buffer list, but not marked as visible in our dictionary, delete it.
	for b in range(1, bufnr('$'))
		if buflisted(b) && !has_key(l:visiblebufs, b)
			call extend(l:closed, [bufname(b)])
			exe 'bdelete ' . b
		endif
	endfor

	if len(l:closed) < 1
		echon "No buffers deleted"
	"elseif len(l:closed) == 1
		"echon "Deleted buffer " . l:closed[0]
	else
		"echon "Deleted " . len(l:closed) . " buffers: " . join(l:closed, ',')
		echon "Deleted " . join(l:closed, ', ')
	endif
	"echon "Deleted " . len(l:closed) . " buffer" . (len(l:closed) == 1 ? '' : 's')
endfunction


function! AppendModeline()
	" Use substitute() instead of printf() to handle '%%s' modeline in LaTeX
	" files.
	let l:modeline = printf(" vim: set ts=%d sw=%d tw=%d %set :",
				\ &tabstop, &shiftwidth, &textwidth, &expandtab ? '' : 'no')
	let l:modeline = substitute(&commentstring, "%s", l:modeline, "")
	call append(line("$"), l:modeline)
endfunction


"""""" Filetype settings

" Map Superconductor filetypes
au BufRead,BufNewFile *.{visualization,widget} set ft=javascript
" .p maps as Prolog (for cs164 project)
au BufRead,BufNewFile *.{p} set ft=prolog

" Turn on spellchecking for vim commit messages
au FileType gitcommit setlocal spell spelllang=en_us

" Highlight shell scripts as bash, not sh
let g:is_posix = 1

" Turn on HTML/DOM highlighting in JavaScript files
let javascript_enable_domhtmlcss = 1


"""""" NERDTree
if janus#is_plugin_enabled("nerdtree")
	call add(NERDTreeIgnore, '\.tmp$')
	let NERDTreeChDirMode=2
	let NERDTreeShowLineNumbers=0
	let NERDTreeStatusline=' '

	nmap <silent> <leader>N :NERDTreeFind<CR>
endif


""""""" NERDTreeTabs
if exists("g:nerdtree_tabs_loaded")
	" These are already handled by vim-session and Janus
	let g:nerdtree_tabs_open_on_gui_startup=0
	let g:nerdtree_tabs_startup_cd=0

	map <Leader>n <plug>NERDTreeTabsToggle<CR>
endif


""""""" BufferGator
if janus#is_plugin_enabled("buffergator")
	" Map <leader>b to toggle, not simply open, the catalog
	nnoremap <silent> <Leader>b :BuffergatorToggle<CR>
	" Open on the right, so as not to interfere with NERDTree
	let g:buffergator_viewport_split_policy="R"
	" Don't expand the GUI window when opening the buffer list
	let g:buffergator_autoexpand_on_split=0
endif


""""""" YouCompleteMe
if exists( "g:loaded_youcompleteme" )
	" Close the function doc window after inserting completion
	let g:ycm_autoclose_preview_window_after_completion = 1
	" Only make down (rather than both tab & down) scroll down through
	" completions
	let g:ycm_key_list_select_completion = ['<Down>']
	" Ditto as above for scrolling up through completions
	let g:ycm_key_list_previous_completion = ['<Up>']

	inoremap <D-a> <C-e>
endif


""""""" CtrlP
if janus#is_plugin_enabled("ctrlp")
	" If a directory with a .ctrlproot file is found in parent directories,
	" mark that as project root
	let g:ctrlp_root_markers=['.ctrlproot']
	let g:ctrlp_open_new_file = 'r'

	" If file is already open in window in this tab, don't open; jump to that
	" window instead.
	" If <C-t> is pressed, only jumps to window if in another tab.
	let g:ctrlp_switch_buffer = 'et'

	" Use <C-p> as 'search buffers' mode (<C-t> is alreadt set to 'search
	" files' mode by Janus)
	nmap <silent> <D-p> :CtrlPBuffer<CR>
endif


""""""" UltiSnips
if exists('did_UltiSnips_vim')
	" Remap expansion key to C-j so that it doesn't interfere with
	" YouCompleteMe
	let g:UltiSnipsExpandTrigger="<C-j>"
endif


""""""" buftabs
"if janus#is_plugin_enabled("buftabs")
"  :set hidden
"  :let g:buftabs_in_statusline=1
"  :let g:buftabs_active_highlight_group="Visual"
"endif


""""""" tagbar
if janus#is_plugin_enabled("tagbar")
	" Sort tags according to file order
	let g:tagbar_sort = 0
endif


""""""" vim-session
if exists("g:loaded_session")
	let g:session_autosave="yes"
	let g:session_autoload="yes"
	let g:session_default_to_last=1

	" After loading a session, find the active file in NERDTree, if it's open
	augroup MTorok
		autocmd SessionLoadPost * call s:syncNerdTree()
	augroup END

	" Reveal in NERDTree any open files within its current path This prevents
	" it from messing up your NERDTree because of one errant file.
	function s:syncNerdTree()
		" Only run if NERDTree is already present
		if exists("t:NERDTreeBufName")

			" This function will be called for every buffer, so filter for the
			" ones we want
			let s:bufPath=expand("%:p")

			" If the file doesn't exist, don't try to show it (this prevents
			" us from trying to show the NERDTree buffer)
			if !file_readable(s:bufPath)
				return
			endif

			" Only show files which are within the current NERDTree path
			let s:filePath = g:NERDTreePath.New(s:bufPath)
			if s:filePath.isUnder(g:NERDTreeFileNode.GetRootForTab().path)
				exe "NERDTreeFind"
			endif

		endif
	endfunction
endif


if exists("g:loaded_numbers")
	nnoremap <F3> :NumbersToggle<CR>
endif

" vim: set ts=4 sw=4 tw=78 noet :
