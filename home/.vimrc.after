""""""" General options {{{1

colorscheme jellybeans+

set softtabstop=4
set tabstop=4
set shiftwidth=4
set noexpandtab

" Put in a highlight after column 100
set colorcolumn=101
"set tw=100

" Highlight the line the cursor is on
set cursorline

" New splits open to the right, or bottom
set splitright
set splitbelow

" Show (partial) command in last line of screen. No idea what it does.
set showcmd

" Don't put "--INSERT--" in command bar when going into insert mode
set noshowmode

" Don't ignore *.out files (as is the Janus default)
set wildignore-=*.out
" Do ignore *.tmp files
set wildignore+=*.tmp

set number


""""""" Startup commands {{{1

" If more than one file is passed to Vim on startup, open each in its own tab
function! Open_all_files_in_tabs()
	if len(argv()) > 1
		" Save the current tab
		let l:currentTab = tabpagenr()
		" `tab`: run the following command and create tabs when it
		" creates windows
		" `sball`: create a window for each buffer
		execute "tab sball"
		" Restore the original tab we opened
		execute 'tabnext' l:currentTab
	endif
endfunction


augroup VimrcStartup
		" 'nested' allows autocmds that run on opening a buffer (such as
		" detecting " filetype) run. Otherwise, all further autocmds prevented
		" from running.
		autocmd VimEnter * nested call Open_all_files_in_tabs()
augroup end


""""""" New commands & shortcuts {{{1

" Mappings {{{2

" Open a new tab with Cmd-T (remaps Janus' mapping of Ctrl-T to :CtrlP
map <D-t> :tabnew <CR>
imap <D-t> <ESC>:tabnew<CR>
" `:VimRC[!]` : Opens all vimrc in separate tabs. If ! is present, will open
" the tabs in the current Vim instance. Otherwise, runs a new MacVim instance
" with the tabs open on startup.
command -bang VimRC call VimEditRC("<bang>")
" <leader>db : Delete buffers not currently loaded in a window
nmap <leader>db :call BufDeleteInvisible()<CR>
" <leader>ml : Append modeline after last line in buffe
nnoremap <silent> <Leader>ml :call AppendModeline()<CR>


" Functions supporting the above commands {{{2

function VimEditRC(bBang)
	" If the command is not proceeded by a '!', open a new MacVim instance
	" and execute commands to load the vimrc files into tabs on startup.
	if a:bBang != "!"
		exec "silent !mvim -c 'edit ~/.vimrc.before' -c 'tabedit ~/.vimrc.after' -c 'tabedit ~/.gvimrc.before' -c 'tabedit ~/.gvimrc.after' -c 'tabnext 2'"
	else
		" If the command is proceeded by a '!', create new tabs directly in
		" this instance of Vim with the vimrc files.
		
		" If the current buffer is empty (only has one buffer, that buffer has
		" a blank filename, is one line long, and that line has no content),
		" load the first file into the current tab.
		if len(tabpagebuflist()) == 1 && bufname("%") == "" && line('$') == 1 && getline(1) == ''
			exec "e ~/.vimrc.before"
		else
			exec "tabedit ~/.vimrc.before"
		endif
		exec "tabedit ~/.vimrc.after"
		let l:vimrcafter = tabpagenr()
		exec "tabedit ~/.gvimrc.before"
		exec "tabedit ~/.gvimrc.after"
		exec "tabnext " . l:vimrcafter
	endif
endfunction

function! BufDeleteInvisible()
	" For each tab page, finds the visible buffers and sets the appropriate
	" key
	" in the dictionary.
	let l:visiblebufs = {}
	for i in range(1, tabpagenr('$'))
		for b in tabpagebuflist(i)
			let l:visiblebufs[b] = 1
		endfor
	endfor

	" Keeps tracks of the buffers we delete so we can show the user a message
	" about what we did when we're done.
	let l:closed = []
	" Iterates through each possible buffer number. If that buffer is in the
	" buffer list, but not marked as visible in our dictionary, delete it.
	for b in range(1, bufnr('$'))
		if buflisted(b) && !has_key(l:visiblebufs, b)
			call extend(l:closed, [bufname(b)])
			exe 'bdelete ' . b
		endif
	endfor

	if len(l:closed) < 1
		echon "No buffers deleted"
	"elseif len(l:closed) == 1
		"echon "Deleted buffer " . l:closed[0]
	else
		"echon "Deleted " . len(l:closed) . " buffers: " . join(l:closed, ',')
		echon "Deleted " . join(l:closed, ', ')
	endif
	"echon "Deleted " . len(l:closed) . " buffer" . (len(l:closed) == 1 ? '' : 's')
endfunction


" Checks the file for possible modelines and returns the line number of the
" first match. If no modeline is found, returns -1
function GetModelineNumber()
	" Match lines of the following two forms, taken from Vim's help
	"	[text]{white}{vi:|vim:|ex:}[white]{options}
	"	[text]{white}{vi:|vim:|Vim:|ex:}[white]se[t] {options}:[text]
	" Note that we do not verify the options themselves. We basically assume
	" the first form for 'vi:', 'vim:' and 'ex:', and then ignore everything
	" after the ':'. If we see 'Vim:', we assume the latter form, but only go
	" so far as to check that 'set' is there (for the second form, 'Vim:' must
	" use 'set', not 'se'.) This makes this regex a little more lenient than
	" Vim's actual checking.
	let l:form1 = '\C^.*[ \t]\+\(vim\=\|ex\):\s*'
	let l:form2 = '^.*[ \t]\+Vim:\s*set '

	" A list of the content of the lines Vim will check for modelines
	let l:lines = getline(1, &modelines)

	let l:match = match(l:lines, l:form1)
	if l:match != -1
		return l:match + 1
	endif
	let l:match = match(l:lines, l:form2)
	if l:match != -1
		return l:match + 1
	endif

	" To read the last &modelines line, figure out the start of the range of
	" lines (last line - &modelines.) Make sure the value we calculate is
	" valid (i.e., greater than 1.)
	let l:lastlineno = (line('$') - &modelines) > 0 ? (line('$') - &modelines) : 1
	let l:lines = getline(l:lastlineno, line('$'))

	let l:match = match(l:lines, l:form1)
	if l:match != -1
		return l:lastlineno + l:match
	endif
	let l:match = match(l:lines, l:form2)
	if l:match != -1
		return l:lastlineno + l:match
	endif
	
	return -1
endfunction

function! AppendModeline()
	" Use substitute() instead of printf() to handle '%%s' modeline in LaTeX
	" files.
	let l:modeline = printf(" vim: set ts=%d sw=%d tw=%d %set:",
				\ &tabstop, &shiftwidth, &textwidth, &expandtab ? '' : 'no')
	let l:modeline = substitute(&commentstring, "%s", l:modeline, "")

	let l:existing = GetModelineNumber()
	if l:existing != -1
		call setline(l:existing, l:modeline)
		echom "Modeline on line " . l:existing . " updated"
	else
		" Add a blank line between the last line and modeline, if one doesn't
		" already exist.
		if getline(line('$')) != ''
			call append(line('$'), '')
		endif
		call append(line("$"), l:modeline)
		echom "Modeline added to end of file"
	endif
endfunction


""""""" Filetype settings {{{1

" Map Superconductor filetypes
au BufRead,BufNewFile *.{visualization,widget} set ft=javascript
" .p maps as Prolog (for cs164 project)
au BufRead,BufNewFile *.{p} set ft=prolog

" Turn on spellchecking for vim commit messages
au FileType gitcommit setlocal spell spelllang=en_us

" Highlight shell scripts as bash, not sh
let g:is_posix = 1

" Turn on HTML/DOM highlighting in JavaScript files
let javascript_enable_domhtmlcss = 1


""""""" NERDTree {{{1
if janus#is_plugin_enabled("nerdtree")
	call add(NERDTreeIgnore, '\.tmp$')
	let NERDTreeChDirMode=2
	let NERDTreeShowLineNumbers=0
	let NERDTreeStatusline=' '

	nmap <silent> <leader>N :NERDTreeFind<CR>
endif


""""""" NERDTreeTabs {{{1
if exists("g:nerdtree_tabs_loaded")
	" These are already handled by vim-session and Janus
	let g:nerdtree_tabs_open_on_gui_startup=0
	let g:nerdtree_tabs_startup_cd=0

	map <Leader>n <plug>NERDTreeTabsToggle<CR>
endif


""""""" BufferGator {{{1
if janus#is_plugin_enabled("buffergator")
	" Map <leader>b to toggle, not simply open, the catalog
	nnoremap <silent> <Leader>b :BuffergatorToggle<CR>
	" Open on the right, so as not to interfere with NERDTree
	let g:buffergator_viewport_split_policy="R"
	" Don't expand the GUI window when opening the buffer list
	let g:buffergator_autoexpand_on_split=0
endif


""""""" YouCompleteMe {{{1
if exists( "g:loaded_youcompleteme" )
	" Close the function doc window after inserting completion
	let g:ycm_autoclose_preview_window_after_completion = 1
	" Only make down (rather than both tab & down) scroll down through
	" completions
	let g:ycm_key_list_select_completion = ['<Down>']
	" Ditto as above for scrolling up through completions
	let g:ycm_key_list_previous_completion = ['<Up>']

	inoremap <D-a> <C-e>
endif


""""""" CtrlP {{{1
if janus#is_plugin_enabled("ctrlp")
	" If a directory with a .ctrlproot file is found in parent directories,
	" mark that as project root
	let g:ctrlp_root_markers=['.ctrlproot']
	let g:ctrlp_open_new_file = 'r'

	" Use <C-p> as 'search buffers' mode (<C-t> is alreadt set to 'search
	" files' mode by Janus)
	map <silent> <D-p> :CtrlPMixed <CR>
	imap <silent> <D-p> <ESC>:CtrlPMixed <CR>

	map <silent> <D-P> :CtrlPMRU <CR>
	imap <silent> <D-P> <ESC>:CtrlPBuffer <CR>

	map <silent> π :CtrlPMRU <CR>
	imap <silent> π <ESC>:CtrlPMRU <CR>
endif


""""""" UltiSnips {{{1
if exists('did_UltiSnips_vim')
	" Remap expansion key to C-j so that it doesn't interfere with
	" YouCompleteMe
	let g:UltiSnipsExpandTrigger="<C-j>"
endif


""""""" buftabs {{{1
"if janus#is_plugin_enabled("buftabs")
"  :set hidden
"  :let g:buftabs_in_statusline=1
"  :let g:buftabs_active_highlight_group="Visual"
"endif


""""""" tagbar {{{1
if janus#is_plugin_enabled("tagbar")
	" Sort tags according to file order
	let g:tagbar_sort = 0
endif


""""""" vim-session {{{1
if exists("g:loaded_session")
	let g:session_autosave="yes"
	let g:session_autoload="yes"
	let g:session_default_to_last=1

	" After loading a session, find the active file in NERDTree, if it's open
	augroup MTorok
		autocmd SessionLoadPost * call s:syncNerdTree()
	augroup END

	" Reveal in NERDTree any open files within its current path This prevents
	" it from messing up your NERDTree because of one errant file.
	function s:syncNerdTree()
		" Only run if NERDTree is already present
		if exists("t:NERDTreeBufName")

			" This function will be called for every buffer, so filter for the
			" ones we want
			let s:bufPath=expand("%:p")

			" If the file doesn't exist, don't try to show it (this prevents
			" us from trying to show the NERDTree buffer)
			if !file_readable(s:bufPath)
				return
			endif

			" Only show files which are within the current NERDTree path
			let s:filePath = g:NERDTreePath.New(s:bufPath)
			if s:filePath.isUnder(g:NERDTreeFileNode.GetRootForTab().path)
				exe "NERDTreeFind"
			endif

		endif
	endfunction
endif


""""""" numbers.vim {{{1
if exists("g:loaded_numbers")
	nnoremap <F3> :NumbersToggle<CR>
endif

" vim: set tabstop=4 shiftwidth=4 textwidth=78 noexpandtab foldmethod=marker :
