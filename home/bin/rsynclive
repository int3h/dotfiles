#!/usr/bin/env bash

# Exit immediately if pipe or subshell exits with non-zero status
set -o errexit
# set -x

# TODO: Allow for multiple syncs to be setup, and exit each when this script gets an exit signal, or
# one of the sync loops has an error.

# TODO: Only sync the changed files? Don't know if this is more/less efficient than letting rsync
# figure it out. We'd also need to make sure to change the dest path to match the path of the single
# file we're uploading. It's possible we don't even need rsync here. If we do use rsync, look into
# the '--files-from=- --from0' option to pass the files to sync from stdin (see man page for
# details.)

progname="$(basename "$0")"

# Defaults
# The directory to create SSH master connection socket file descriptors
# ssh_master_control_path="/tmp/rsync_ssh_control/$USER"
# ssh_master_socket_name="%u.%h.%p.%r"
# # Time the background SSH master connection process should sit idle before exiting & closing socket
# ssh_master_timeout="30s"

# ssh_command="ssh -S \"$ssh_master_control_path/$ssh_master_socket_name\" -o 'ControlMaster auto' -o 'ControlPersist $ssh_master_timeout'"

latency="1.0"
# -a = -rlptgoD
#  --update
rsync_options="--archive --no-owner --no-group --executability --compress -h -h -h --exclude-from=$HOME/.rsync_exclude.conf -F --rsh=ssh"
fswatch_options='--one-per-batch --recursive --print0 --exclude /\.git/\{0,1\} --exclude /4913$ --exclude /node_modules/\{0,1\} --exclude /build/\{0,1\} --exclude /\.DS_Store$'




src=
dest=
src_nonlocal=
verbose=
clr_msg="$(tput setaf 6)"
clr_err="$(tput setab 1)"
clr_reset="$(tput sgr0)"

usage="Usage: $progname [-h] [-v] [-t <latency>] [-r <rsync option>...] <src> <dest>"
helpmsg="Watch <src> (if local path) for changes and rsync them to <dest>

$usage

Options:
  -h, --help                  show this help message and exit
  -v, --verbose               increase verbosity
  -t, --throttle <latency>    delay <latency> seconds (a double) after a fs
                              event before invoking rsync (default: 3.0)
  -r, --rsopt <rsync option>  options to pass to rsync when invoking

When run, will perform an rsync from <src> to <dest>. Then, if <src> is a local
path, a filesystem event watcher will be set up to watch <src> and all of its
children, and will invoke rsync again when it detects changes."


################################################################################
################################################################################


# Parses command-line arguments to this script and takes appropriate action
parse_arguments() {
    while [[ $# > 0 ]]; do
        option="$1"
        shift

        case $option in
            -h|--help)
                echo "$helpmsg"
                exit 0
                ;;
            -v|--verbose)
                verbose=1
                rsync_options="$rsync_options -v"
                exec 3>&2
                ;;
            -t|--throttle)
                [[ $# < 1 ]] && echo "ERROR: argument required for option '$option'" >&2 && exit 7

                latency="$1"
                shift
                ;;
            -r|--rsopt)
                [[ $# < 1 ]] && echo "ERROR: argument required for option '$option'" >&2 && exit 3

                rsync_options="$rsync_options $1"
                shift
                ;;
            -- )
                src="$1"
                dest="$2"
                break
                ;;
            *)
                if [[ -z $src ]]; then
                    src="$option"
                elif [[ -z $dest ]]; then
                    dest="$option"
                else
                    echo "ERROR: unknown option '$option'"
                    echo "$usage"
                    exit 1
                fi
                ;;
        esac
    done

    if [[ -z $src ]] || [[ -z $dest ]]; then
        echo "ERROR: must supply both source and destination path" >&2
        exit 2
    fi

    if [[ "$src" =~ *:* ]]; then
        [[ $verbose ]] && echo "Source '$src' is non-local and can not be watched. Will run \`rsync\` once and exit." >&2
        src_nonlocal=1
    fi
}

################################################################################


load_config() {
    echo ""
}


################################################################################


# Does some basic sanity/requirements checking on the local machine, and exits if they fail
check_system() {
        if ! type -t rsync 2>&1 >/dev/null; then
        echo "ERROR: \`rsync\` not found. Make sure \`rsync\` is installed and in your \$PATH." >&2
        exit 4
    fi
    if ! type -t fswatch 2>&1 >/dev/null; then
        echo "ERROR: \`fswatch\` not found. Make sure \`fswatch\` is installed and in your \$PATH" >&2
        exit 5
    fi
}


################################################################################

# Creates a background SSH control socket process to multiplex SSH on
# setup_ssh() {
#     local ssh_server="$1"

#     install -d -m 0700 "$ssh_master_control_path"

#     # printf 'SSH command: %s\n\n' "${ssh_command} -q -O check \"$ssh_server\""

#     # # Check if the control socket already exists
#     # if eval $ssh_command -O check $ssh_server; then
#     #     printf '%sSSH master connection to server %s already exists; reusing%s\n\n' "$clr_msg" "$ssh_server" "$clr_reset"
#     # else
#     #     printf '%sCreating SSH master connection to server %s... %s' "$clr_msg" "$ssh_server" "$clr_reset"
#     #     if eval $ssh_command $ssh_server exit; then
#     #         printf '%s success%s\n\n' "$clr_msg" "$clr_reset"
#     #     else
#     #         printf "%sERROR: could not connecting to SSH server %s%s\n" "$clr_err" "$ssh_server" "$clr_reset"
#     #         exit 6
#     #     fi
#     # fi

#     # if ! ssh -S "$ssh_master_control_path/%u.%h.%p.%r" -o "ControlMaster auto" -o "ControlPersist $ssh_master_timeout" -q "$ssh_server" exit
# }

################################################################################

# Handle exit cleanup, and specifically shutting down the SSH control socket
on_exit() {
    echo
}


################################################################################


sync() {
    #printf 'rsync %s "%s" "%s"\n\n' "$rsync_options" "$src" "$dest" >&3
    local rsync_one_time_options="$1"

    printf '%sSending new files...%s\n' "$clr_msg" "$clr_reset" >&3
    printf '%s>%s rsync %s %s "%s" "%s"\n\n' "$clr_msg" "$clr_reset" "$rsync_options" "$rsync_one_time_options" "$src" "$dest" >&3

    rsync $rsync_options $rsync_one_time_options "$src" "$dest"

    local rsync_return=$?
    if [[ $rsync_return != 0 ]]; then
        printf '\n%sERROR: rsync reported an error while trying to sync (error code: %s)%s\n' "$clr_err" "$rsync_return" "$clr_reset" >&2
        printf 'Command: rsync %s %s "%s" "%s"\n' "$rsync_options" "$rsync_one_time_options" "$src" "$dest" >&2
        exit $rsync_return
    fi

    [[ $verbose ]] && type -t terminal-notifier >/dev/null && \
        terminal-notifier -sender com.apple.Terminal -group com.int3h.rsynclive -open "file://$(pwd)/$src/" -title "Sync Completed" -message "$dest" 2>&1 >/dev/null

    [[ $src_nonlocal ]] || printf "\n%sWatching %s/ for modifications... %s" "$clr_msg" "$src" "$clr_reset" >&3
}


################################################################################
################################################################################

exec 3>/dev/null

parse_arguments "$@"
check_system

# Perform initial rsync
printf "%sSetting up sync of directory %s to %s%s\n" "$clr_msg" "$src" "$dest" "$clr_reset"
printf -- '-- Will wait %s sec before uploading modified files to let local file writes complete.\n\n' "$latency"

# setup_ssh "${dest%%:*}"

sync '--checksum'

if [[ $src_nonlocal ]]; then
    printf '%sExiting after initial sync due to source "%s" being non-local%s\n\n' "$clr_msg" "$src" "$clr_reset" >&3
    exit 0
fi

while read -d '' num_files_changed; do
    printf '%s%s file(s) changed, syncing%s\n\n' "$clr_msg" "$num_files_changed" "$clr_reset"
    sync
done < <(fswatch $fswatch_options --latency "$latency" "$src")
