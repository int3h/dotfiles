#!/usr/bin/env bash

########
# This script kicks off a small web server in order to test out the site running
# in the browser. If $WEBKITWEBCL_PATH is set in your environment to the path of
# WebKit.app, or can be set by sourcing ~/.webkitwebcl, then we also run the
# special WebKit WebCL browser, disable its caches, and direct it to the local
# server. We re-open this app every time we quit (to faciliate the common
# pattern of restarting your browser when testing code) until Ctrl+C is sent to
# this script in the terminal.
########


# TODO: If WebKit.app path isn't set via env var or config file, should we
# use `mdfind 'kMDItemCFBundleIdentifier == "org.webkit.nightly.WebKit"'` to
# find it instead of asking the user? Optionally, if we find >1 result, we can
# save the last version we used (globally or locally?) and re-use that, or use
# `mdls -raw -name kMDItemVersion /Users/mtorok/Downloads/WebKitWebCL.app` to
# get the build/version number and use the latest we find.

# TODO: We should periodically check the position of the WebKit.app window and
# re-record its position. This will allow us to launch subsequent WebKit windows
# in the same location, even if the user changes the location after launch.
# (Presently, we only record position on launch and restore that position when
# launching subsequent WebKit windows.) At the least, we should reset the
# position if the user plugs/unplugs screens (detected as a change in desktopn
# resolution?)

# TODO: If we can capture the URL of the browser when it quits, we should open
# up the browser to that same URL on re-launch.


################################################################################
# Global preferences
################################################################################

default_server_addr="127.0.0.1"
default_server_port="8888"

# Launch WebKit WebCL only once (not in a loop,) and disable showing the web inspector on launch
# (default: false)
launch_once=''
# Write current options to local config file in this directory (default: false)
save_options=''
# Whether or not to reset config files before running (default: false)
reset_conf=''

conf_file_path="$HOME/.webkitwebcl.conf"
conf_file_local_path=".webkitwebcl.conf"

# Output message colors
message_color="$(tput bold)$(tput setab 6)"
quit_color="$(tput bold)$(tput setab 1)"
question_color="$(tput setaf 1)"
reset_color="$(tput sgr0)"


################################################################################
# Global state
################################################################################

# The address and port to run the server on (set by config, args, or defaults)
server_addr=''
server_port=''

# The PID of the running Python HTTP server (if it is running; empty otherwise)
server_pid=''

# The path to the WebKit.app to open our browser in
webkit_path=''


################################################################################
# Functions
################################################################################

# Print a usage/help message to STDOUT
print_help() {
	echo "Usage: $(basename "$0") [OPTION]... [[<ip>] <port>]"
	printf "Test WebCL programs by serving the current directory over HTTP, and continually \
opening WebKit WebCL to it until the script is terminated.\n" | fold -s -w 80
	printf "<port> and <ip> are the port and local IP address the server binds to (defaults to \
%s:%s). <port> is required if <ip> is present.\n\n" \
"${default_server_addr}" "${default_server_port}" | fold -s -w 80

	echo "Options:"
    echo "  -1, --once     Don't re-launch WebKit when quit, or show inspector on launch"
	echo "  -S, --save     Save settings locally to current directory"
	echo "  -R, --reset    Delete the local and global config files before continuing"
	echo "  -h, --help     Show this help message and exit"


	printf "\n\nConfiguration is stored per-directory in .webkitwebcl.conf and user-wide in \
~/.webkitwebcl.conf.\n" "$conf_file_local_path" "$conf_file_path" | fold -s -w 80
}


# Retrieve and set program preferences
get_prefs() {
	[[ -f "$conf_file_local_path" ]] && . "$conf_file_local_path" && printf 'Using settings from local config file: %s\n' "$conf_file_local_path"
	[[ -f "$conf_file_path" ]] && . "$conf_file_path" && printf 'Using settings from global config file: %s\n' "$conf_file_path"
	printf '\n'

	# If WebKit path isn't set by any user settings, search or ask for it
	if [[ -z $WEBKITWEBCL_PATH ]]; then
		printf 'No path to WebKit app found in program configuration.\n'

		local possible_webkit="$(find_latest_webkit)"
		if [[ -n "$possible_webkit" ]]; then
			printf -- '-- Found a WebKit nightly build at: %s (version: r%s)\n\n' "$possible_webkit" "$(get_webkit_version "$possible_webkit")"

			local use_found_webkit=''
			printf -- '%sWould you like to use "%s" as your WebKit WebCL browser?%s (y/n): ' "$question_color" "$possible_webkit" "$reset_color"
			read -n 1 use_found_webkit
			printf '\n'
			if [[ "$use_found_webkit" == y || "$use_found_webkit" == "Y" ]]; then
				local WEBKITWEBCL_PATH="$possible_webkit"
			fi
		fi

		if [[ -z "$WEBKITWEBCL_PATH" ]]; then
			# Pop up an AppleScript dialog asking the user to select the app
			local WEBKITWEBCL_PATH="$(echo "$(cat <<APPCHOOSER
try
	set webKitApp to choose application as alias with title "Select WebKit.app" with prompt "Please select WebKit.app"

	return POSIX path of webKitApp
on error number -128
	display alert "WebKit.app not selected.

WebKit.app could not be located. Exiting." as critical
	return ""
end try
APPCHOOSER
			)" | osascript - )"
		fi

		# Notify them we saved it
		[[ -f "$conf_file_path" ]] || printf -- "-- Will save WebKit path to user config file '%s'. Will not \
prompt for path in the future.\n\n" "$conf_file_path" | fold -s -w "$(tput cols)"
	fi

	# If the user hit 'Cancel' on the file chooser dialog, then
	# $WEBKITWEBCL_PATH will be empty. Show an error, then exit.
	if [[ -z "$WEBKITWEBCL_PATH" ]]; then
		printf '%sError: Could not find path to WebKit app. Exiting.%s\n' "$quit_color" "$reset_color" >&2
		exit 1
	fi

	if [[ ! -d "$WEBKITWEBCL_PATH" ]]; then
		printf "%sError: Could not find WebKit app at '%s'. Bad configuration file or program argument?%s\n" \
"$quit_color" "$WEBKITWEBCL_PATH" "$conf_file_path" "$reset_color" | fold -s -w $(tput cols) >&2
		exit 2
	fi


	# Save the user's selection to the config file
	printf 'WEBKITWEBCL_PATH="${WEBKITWEBCL_PATH:-%s}"\n' "$WEBKITWEBCL_PATH" > "$conf_file_path"


	server_addr="${server_addr:-$default_server_addr}"
	server_port="${server_port:-$default_server_port}"

	webkit_path="$WEBKITWEBCL_PATH"
} # /get_prefs()


# Save the local options for this directory
save_options() {
	printf 'Saving options to local config file: %s\n\n' "$conf_file_local_path"

	printf 'WEBKITWEBCL_PATH="${WEBKITWEBCL_PATH:-%s}"\n' "$webkit_path" > "$conf_file_local_path"
	printf 'server_addr="${server_addr:-%s}"\n' "$server_addr" >> "$conf_file_local_path"
	printf 'server_port="${server_port:-%s}"\n' "$server_port" >> "$conf_file_local_path"
}


# Prints the path to the highest version of WebKit nightly found on the system, or nothing if none
# found.
find_latest_webkit() {
	local all_webkits="$(mdfind 'kMDItemCFBundleIdentifier == "org.webkit.nightly.WebKit"' 2>/dev/null)"
	[[ -z "$all_webkits" ]] && printf '' && return

	local webkit=''
	local latest_webkit=''
	local latest_version=''

	read -r webkit <<< "$all_webkits"
	latest_webkit="$webkit"
	latest_version="$(get_webkit_version "$webkit")"

	while read -r webkit; do
		# if [[ -z "$latest_webkit" ]]; then
		# 	latest_webkit="$webkit"
		# 	latest_version="$(get_webkit_version "$webkit")"
		# else
			if [[ "$(get_webkit_version "$webkit")" -gt "$latest_version" ]]; then
				latest_webkit="$webkit"
				latest_version="$(get_webkit_version "$webkit")"
			fi
		# fi
	done <<< "$all_webkits"

	[[ -z "$latest_version" ]] && printf '' && return
	echo "$latest_webkit"
}


# Given the path to a WebKit version, prints the version number (or an empty
# string if none found)
get_webkit_version() {
	mdls -raw -nullMarker '' -name kMDItemVersion "$1" | cut -c 2-
}


# # Resets the local and global config files
reset_conf() {
	[[ -f "$conf_file_local_path" ]] && command rm "$conf_file_local_path"
	[[ -f "$conf_file_path" ]] && command rm "$conf_file_path"
}


# Run a Python HTTP server in the background and set $server_pid to its PID
run_server() {
	local ip="$1"
	local port="$2"

	# Run the server in the background, but save its PID so we can kill it when this script exits
	echo "$(cat <<PYTHON
#!/usr/bin/env python

from __future__ import print_function
import sys

if sys.version_info[0] <= 2:
    import SimpleHTTPServer, BaseHTTPServer
    HandlerClass = SimpleHTTPServer.SimpleHTTPRequestHandler
    ServerClass = BaseHTTPServer.HTTPServer
else: # Python >= 3
    import http.server
    HandlerClass = http.server.SimpleHTTPRequestHandler
    ServerClass = http.server.HTTPServer

server_address = ("${ip}", ${port})

HandlerClass.protocol_version = "HTTP/1.0"
httpd = ServerClass(server_address, HandlerClass)
sa = httpd.socket.getsockname()
print("Serving HTTP on", sa[0], "port", sa[1], "...\n")

try:
    httpd.serve_forever()
except KeyboardInterrupt:
    print("\nKeyboard interrupt received, exiting.")
    httpd.server_close()
    sys.exit(0)

PYTHON
	)" | python &

	# We can't `echo $!` because doing so hangs calls to this functions (I think
	# it's nesting the call to this in a subshell `$(run_site)`, then having
	# this function run and detach from `python`.)
	server_pid="$!"
}


run_browser() {
	local ip="$1"
	local port="$2"
	local webkit_window_bounds="$3"

	# The TTY of the terminal that spawned this script, so that we can activate
	# the terminal window/tab (identified by TTY) later
	local spawning_tty="$(tty)"

	# Tell WebKit WebCL to not save/restore window on exit/launch
	defaults write org.webkit.nightly.WebKit ApplePersistenceIgnoreState 0 2>&1 >/dev/null

	# The AppleScript to launch WebKit WebCL, disable its caches, and open the page to the local server
	local launch_script="$(cat <<APPLESCRIPT
on run argv
	-- The bounds of the last WebKit window may be passed as the first argument
	-- on the command line
	if length of argv > 0
		-- Split argv into a list with ',' as the seperator (if argv[0] is
		-- empty, it will turn into a 0-length list, which is fine.)
		set AppleScript's text item delimiters to ", "
		set oldBounds to (text items of (item 1 of argv))
	else
		set oldBounds to {}
	end if

	-- Activate the terminal window containing the tab running this script. This
	-- will (hopfully) activate the Desktop that the Terminal window containing
	-- that tab is running in.
	-- This is not sufficient to launch WebKit in the same desktop as it in
	-- multi-monitor setups, since OS X will still happily launch WebKit in
	-- the other monitor (since it sees it as all one desktop.) For that, we
	-- need to set the window bounds,
	tell application "Terminal"
		repeat with win in windows
			repeat with curTab in (tabs in win)
				if tty in curTab is "${spawning_tty}" then
					activate
					activate win
					set frontmost of win to true
				end if
			end repeat -- /tabs
		end repeat -- /windows
	end tell

	tell application "$webkit_path" to activate

	tell application "System Events"
		tell process "WebKit"
			tell menu "Develop" of menu bar 1
				click menu item "Empty Caches"
				-- If "Disable Caches" isn't already checked, click it
				if (value of attribute "AXMenuItemMarkChar" of menu item "Disable Caches") ≠ "✓" then
					click menu item "Disable Caches"
				end if
			end tell
		end tell
	end tell

	tell application "$webkit_path"
		tell window 1
			-- If we know the bounds of the WebKit window from the last time we
			-- launched it, move the new window to that position
			if length of oldBounds >= 2
				-- Calculate the current width and height
				set curBounds to bounds
				set curWidth to (item 3 of curBounds) - (item 1 of curBounds)
				set curHeight to (item 4 of curBounds) - (item 2 of curBounds)

				-- Calculate the new width and height by placing the upper-left
				-- corner in the old position, and the lower-right corner in
				-- a position so that the width and height are equal to the
				-- current width and height
				set newBounds to {item 1 of oldBounds, item 2 of oldBounds, ((item 1 of oldBounds) + curWidth), ((item 2 of oldBounds) + curHeight)}

				set bounds to newBounds
			end if
			set webkitBounds to bounds

			set URL of current tab to "http://${ip}:${port}"
		end tell
	end tell

	if "${dev_mode}" equals "1"
		tell application "System Events"
			-- set SafariCL to application process "WebKit"
			-- set frontmost of SafariCL to true
			tell process "WebKit"
				tell menu "Develop" of menu bar 1
					if (exists menu item "Show Web Inspector")
						-- We also tried checking and if
						-- (value of attribute "AXEnabled" of menu item "Show Web Inspector")
						-- is true, to make sure we're able to click the menu
						-- item, but it seemed to be always false, and its
						-- falseness didn't seem to impede clicking it.
						click menu item "Show Web Inspector"
					end if -- /menu exists
				end tell
			end tell
		end tell
	end if

	return webkitBounds
end run

APPLESCRIPT
	)"

	# Run the "launch WebKit" AppleScript, passing $webkit_window_bounds as the
	# first argument, and saving the return value of the script as the new
	# $webkit_window_bounds.
	echo "$launch_script" | osascript - "${webkit_window_bounds}"
}


run_site() {
	local ip="$1"
	local port="$2"
	local webkit_window_bounds=''

	run_server "$server_addr" "$server_port"

	if [[ -z "$launch_once" ]]; then
		# Infinitely re-launch WebKit WebCL, until Ctrl+C is called
		while :
		do
			webkit_window_bounds=$(run_browser "$ip" "$port" "$webkit_window_bounds")
			trap on_quit SIGINT
			open -W -a "$webkit_path" >/dev/null

			printf "\n%sRelaunching Safari. Press Ctrl+C to stop.%s\n\n" "$message_color" "$reset_color"
		done
	else
		webkit_window_bounds=$(run_browser "$ip" "$port" "$webkit_window_bounds")
		trap on_quit SIGINT
		open -W -a "$webkit_path" >/dev/null

		on_quit
	fi
}


# The code to run when we exit (either by pressing Ctrl+C, or other means)
on_quit() {
	printf "\n\n%sExiting...%s\n" "$quit_color" "$reset_color"

	# The AppleScript to quit WebKit WebCL (called when this script exits)
	local quit_script="$(cat <<APPLESCRIPT
tell application "$webkit_path"
	if it is running then
		quit
	end if
end tell
APPLESCRIPT
	)"
	echo "$quit_script" | osascript -

	if [[ $server_pid ]]; then
		kill $server_pid 2>/dev/null
	fi

	exit
}



################################################################################
# Parse program arguments and run the site
################################################################################

while [[ $# -gt 0 ]]; do
	case "$1" in
		-h)
			print_help
			exit 0
			;;
		-H)
			print_help
			exit 0
			;;
		--help)
			print_help
			exit 0
			;;
		-1)
			launch_once=1
			;;
		--once)
			launch_once=1
			;;
		-S)
			save_options=1
			;;
		--save)
			save_options=1
			;;
		-R)
			reset_conf=1
			;;
		--reset)
			reset_conf=1
			;;
		*)
			if [[ -z "$server_port" ]]; then
				server_port="$1"
			else
				if [[ -z "$server_addr" ]]; then
					server_addr="$server_port"
					server_port="$1"
				else
					printf '%sError: unrecognized option "%s"%s\n\n' "$quit_color" "$1" "$reset_color"
					print_help
					exit 1
				fi
			fi
			;;
	esac
	shift
done

[[ -n "$reset_conf" ]] && reset_conf
get_prefs
[[ -n "$save_options" ]] && save_options
run_site "$server_addr" "$server_port"

# In case it didn't get run above, for whatever reason (if it is run above, then
# trapped should `exit` the script, and this line will never be seen.)
on_quit
