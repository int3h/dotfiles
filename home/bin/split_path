#!/usr/bin/env python
from __future__ import unicode_literals, print_function, absolute_import, division
import os.path, os
from sys import argv, stderr, stdout


def print_help():
    from textwrap import wrap
    term_wrap = lambda long_msg: "\n".join(wrap(long_msg, 80)) + "\n"

    stdout.write("Usage: split_path [-h|--help] <PATH>\n")
    stdout.write("Split <PATH> into directory, base name, and extension parts.\n")
    stdout.write("Prints each part, respectively, on a line to STDOUT.\n\n")

    stdout.write(term_wrap("The given <PATH> may leave out one or more parts. In this case, the \
printed string will have an empty line for that part.") + "\n")
    
    stdout.write(term_wrap("If a file has multiple extensions, the \"extension\" part will contain \
all of them. For example, the file 'book.pdf.zip' will have a \"base\" part of 'book' and an \
extension part of '.pdf.zip'. Consequently, files with dots in their name, other than as a \
extension separator, may not be parsed correctly. Further, files that begin with a dot (such as \
'.bash_rc') will be considered to have their full name as the \"base\" part, and no extension.") + "\n")

    stdout.write(term_wrap("A <PATH> with a trailing '{sep}' is assumed to be a directory path (and \
thus, the \"base\" and \"extension\" parts will be empty); a <PATH> without a trailing '{sep}' is \
assumed to be a file and the last part of <PATH> will be used to find the \"base\" and \
\"extension\" parts of the path.".format(sep=os.sep)))

    stdout.write("\nOptions:\n")
    stdout.write("  -h, --help    print this message and exit\n")


args = argv[1:]

if ("-h" in args) or ("--help" in args):
    print_help()
    exit(0)
if len(argv) != 2:
    stderr.write("Error: wrong number of arguments (expected 1, found " + str(len(argv)) + ")\n\n")
    print_help()
    exit(1)

# TODO: Add an option to print each part of the path on a new line, instead of as a series of quoted
# string?

# TODO: Add an option to print the parts of the path in BASH variable assignment form? That is, the
# output of this command will be BASH commands to set the $split_path_dir, $split_path_base and
# $split_path_extension variables. We'll have to look up how to get BASH to execute the output of
# a command as BASH commands (and be sure that the variables it sets are visible to the script
# afterward.) Depending on how BASH works, we may want to add a further option to make the variable
# declarations 'local'.



input_path = args[0]

directory, filename = os.path.split(input_path)

if filename != '':
    file_base, file_extension = os.path.splitext(filename)
    while os.path.splitext(file_base)[1] != '':
        file_base, extra_extension = os.path.splitext(file_base)
        file_extension = extra_extension + file_extension
else:
    file_base = ''
    file_extension = ''



stdout.write("{directory}\n{base}\n{ext}\n".format(directory=directory, base=file_base, ext=file_extension))

